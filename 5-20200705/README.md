## 算法考察：Next Permutation

leetcode 31.下一个排列

## 请描述下为什么页面需要做优化？并写出常用的页面优化实现方案？

页面性能的问题对用户体验的影响非常大，加载时间每多 1 秒，你就会流失 7%的用户，在正常页面的情况下，若页面加载时间超过 8 秒时间，那么你可能会损失 85%以上的用户。

页面进行优化，其实有两种优化方式

- 软件优化
- 硬件优化

#### 软件优化

1. html 优化
   布局优化，减少空格，不用 table 布局，尽量不用 iframe 标签
2. css 优化
   可以用 css 实现的尽量不用 js 实现；css 代码压缩；css 合并；用字体图标代替图片；
   开启 css 硬件加速：transform 动画由 GPU 控制，支持硬件加速，并不需要软件方面的渲染，使用 top 和 left 实现动画时浏览器发生的 repaint

3. js 优化
   图片优化(预加载/懒加载/延时加载)；视频或音频不加载，当点击之后开始单独加载视频或音频；
   在 js 中尽量减少闭包的使用（原因：闭包会产生不释放的栈内存）
   DOM 的操作
   其实 css 压缩与 js 的压缩和混乱比 html 压缩收益要大得多，同时 css 代码和 js 代码比 html 代码多得多，通过 css 压缩和 js 压缩带来流量的减少，会非常明显。

4. http 优化
   尽量减少需要发送的 http 请求；

5. 缓存方面
   使用浏览器的缓存机制，不需要每次登录或者怎么样都需要再去访问服务器；  
    利用浏览器和服务器端的缓存技术（304 缓存），把一些不经常更新的静态资源文件做缓存处理

#### 硬件优化

1. 设置负载均衡服务器
   通过负载均衡服务器使得后台数据压力平衡；

2. 增加带宽
   但是硬件的成本远远高于软件优化。

## 请描述下 JavaScript 中 Scope、Closure、Prototype 概念，并说明 JavaScript 封装、继承实现原理。

### Lexical scope 词法作用域

https://github.com/linesh-simplicity/linesh-simplicity.github.io/issues/131
作用域是什么呢？它指的是你的变量和函数运行到某个地方的代码处能否被访问到。为什么需要作用域呢？为什么要限制变量的访问性而非全部暴露到公共域下呢？这是计算机科学中最基本的概念和理念：隔离性（The Principle of Least Access）。为了职责明确，你只能刚好访问到你需要的所有东西，不多也不少。附带地，它带来了模块化、命名空间等好处，让你写出更易阅读、更易维护的代码。可以说，作用域是许多现代编程语言都从语言层面支持的一个特性。

- 全局作用域：不定义在任何函数以内的变量或函数都位于全局作用域下。
- 函数作用域：任何定义在函数内的变量或函数都处于函数作用域下，这些变量无法在函数以外被引用到
- 块作用域：ES6 之前是没有这个东西的，也就是说，定义在 { } 大括号对 及 for (i = 0; i < 10; i++) { ... } 循环结构中的变量统统都会跑到全局作用域下去。这就很违反直觉了。ES6 通过 let 和 const 关键字修复了这个问题，并且赋予了一般的块 block 以块作用域
  上下文与作用域是非常不同的概念。作用域是静态的分析概念，它在你代码写完后就唯一确定下来了，指示变量对所有代码的可见性；而上下文是动态的运行时概念，它指的是代码运行时同个作用域下 this 值的指向。
  执行上下文即是运行时用来描述词法作用域所表示的变量对不同函数、代码可见性的一段内存和数据结构，简称环境。

### 执行上下文栈 Execution Context Stack

由于 JavaScript 是个单线程模型的编程语言，因此任一时刻，正在运行的执行上下文只能有一个，称为 active EC；其他的 EC 则依它们被调用的先后次序，形成了一个后入先出的栈结构，简称 EC Stack。最地下的 EC 通常是 Global EC。

### EC 的创建与闭包实现的关键：作用域链 Scope Chain

每个函数执行时，都会生成一个 EC。EC 的生成过程分为两个阶段：
环境准备阶段，引擎会准备并填充三个变量，保存到该创建的执行上下文中。里面的这些变量是代码执行过程所需要的所有变量的集合。三个变量分别为：

- Variable Object 变量对象。主要包含了一些函数参数啊、函数定义的内部变量及其他声明等
- Scope Chain 作用域链。它是词法作用域的静态描述，是实现闭包的关键要素之一！！太神奇了
- this 关键字的值。填充好该函数的 this 的值

### Closures

闭包的定义：从实现上讲，闭包是一条记录，它存储了一个函数与其环境的上下文信息。这个上下文主要记录了：函数的每个自由变量（在内层函数使用，但在外层函数处被定义的变量）与其被绑定的值或引用之间的关联,主要是用来实现信息封装。

## 你是如何组织 JavaScript 代码的？（可以从模块、组件、模式、编程思想等方面回答）

## 请列出目前主流的 JavaScript 模块化实现的技术有哪些？说出它们的区别？

## 介绍下 Flex 布局，属性都有哪些，都是干啥的

#### 容器的属性

flex-direction：决定主轴的方向（即项目的排列方向）。

- row（默认值）：主轴为水平方向，起点在左端。
- row-reverse：主轴为水平方向，起点在右端。
- column：主轴为垂直方向，起点在上沿。
- column-reverse：主轴为垂直方向，起点在下沿。

flex-wrap：默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap 属性定义，如果一条轴线排不下，如何换行。

- nowrap（默认）：不换行。
- wrap：换行，第一行在上方。
- wrap-reverse：换行，第一行在下方。

flex-flow
flex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap。

justify-content：项目在主轴上的对齐方式。

- flex-start（默认值）：左对齐
- flex-end：右对齐
- center： 居中
- space-between：两端对齐，项目之间的间隔都相等。
- space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。

align-items：项目在交叉轴上如何对齐。

- flex-start：交叉轴的起点对齐。
- flex-end：交叉轴的终点对齐。
- center：交叉轴的中点对齐。
- baseline: 项目的第一行文字的基线对齐。
- stretch（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度。

align-content：多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。

- flex-start：与交叉轴的起点对齐。
- flex-end：与交叉轴的终点对齐。
- center：与交叉轴的中点对齐。
- space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。
- space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
- stretch（默认值）：轴线占满整个交叉轴。

#### 项目的属性

order:排列顺序。数值越小，排列越靠前，默认为 0。

flex-grow:放大比例，默认为 0，即如果存在剩余空间，也不放大。

flex-shrink:项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。

flex-basis:在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto，即项目的本来大小

flex 属性是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。后两个属性可选。该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。

align-self:允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。

## 子组件可以直接改变父组件的数据么，说明原因
